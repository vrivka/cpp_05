# C++ - modules

C++ - modules серия задач для изучения различных аспектов языка C++ и ООП.

## Ссылки на другие модули

0. [CPP module 00](https://github.com/vrivka/cpp_00)
1. [CPP module 01](https://github.com/vrivka/cpp_01)
2. [CPP module 02](https://github.com/vrivka/cpp_02)
3. [CPP module 03](https://github.com/vrivka/cpp_03)
4. [CPP module 04](https://github.com/vrivka/cpp_04)
5. CPP module 05
6. [CPP module 06](https://github.com/vrivka/cpp_06)
7. [CPP module 07](https://github.com/vrivka/cpp_07)
8. [CPP module 08](https://github.com/vrivka/cpp_08)

# C++ - Module 05

## Описание модуля

Этот модуль разработан, чтобы помочь понять Try/Catch и исключения в C++.

## Задачи

### Exercise 00: Mommy, when I grow up, I want to be a bureaucrat!

Во-первых, начнем с самого маленького винтика в этой огромной бюрократической машине: `Bureaucrat`.

`Bureaucrat` должен иметь:
- Константу `name`
- И `grade` в диапазоне от 1 (самая высокая оценка) до 150 (самая низкая оценка)

Любая попытка создать экземпляр `Bureaucrat` с использованием недопустимой оценки должна вызвать исключение: либо `Bureaucrat::GradeTooHighException`, либо `Bureaucrat::GradeTooLowException`.

Нужно предоставить геттеры для обоих этих атрибутов: `getName()` и `getGrade()`. Также реализовать две функции-члены для увеличения или уменьшения ранга `Bureaucrat`. Если оценка выходит за пределы диапазона, оба они будут генерировать те же исключения, что и конструктор.

Реализовать перегрузку оператора вставки `<<` для вывода чего-то вроде:

```
<name>, bureaucrat grade <grade>
```

### Exercise 01: Form up, maggots!

Теперь, когда у нас есть бюрократы, давайте дадим им какое-нибудь дело. Что может быть лучше, чем заполнение стопки форм?

Создадим класс `Form`. В нем есть:
- Константное `name`
- Логическое значение, указывающее, подписана ли форма (при построении — нет)
- Константная оценка, необходимая для её подписания.
- Константная оценка, необходимая для её выполнения.

Все эти атрибуты являются `private`, а не `protected`.

Оценки `Form` следуют тем же правилам, которые применяются к `Bureaucrat`. Таким образом, если оценка формы выходит за допустимые пределы, будут выброшены следующие исключения: `Form::GradeTooHighException` и `Form::GradeTooLowException`.

Как и раньше, нужно написать геттеры для всех атрибутов и перегрузку оператора вставки <<, который выводит всю информацию о форме.

Также добавить функцию-член `beSigned()` в `Form`, которая принимает `Bureaucrat` в качестве параметра. Меняет статус формы на подписанный, если ранг бюрократа достаточно высок (выше или равен требуемому). Если оценка слишком низкая, выбрасывается исключение `Form::GradeTooLowException`.

Наконец, добавить функцию-член `signForm()` в `Bureaucrat`. Если форма была подписана, она напечатает что-то вроде:

```
<bureaucrat> signed <form>
```

В противном случае напечатается:

```
<bureaucrat> couldn’t sign <form> because <reason>
```

### Exercise 02: No, you need form 28B, not 28C...

Поскольку теперь у нас есть базовые формы, пришло время сделать еще несколько, которые действительно что-то делают.

Во всех случаях базовый класс `Form` должен быть абстрактным классом. Атрибуты `From` должны оставаться `private` и принадлежать базовому классу.

Создадим следующие конкретные классы:
- `ShrubberyCreationForm` - Требуемые оценки: подписание 145, исполнение 137

Создает файл `<target>_shrubbery` в рабочем каталоге и запишет в него ASCII-дерево.

- `RobotomyRequestForm`: Требуемые оценки: подписание 72, исполнение 45

Издает некоторые звуки сверления. Затем сообщает, что `<target>` была успешно роботизирована в половине случаев. В противном случае сообщает, что роботизация не удалась.

- `PresidentialPardonForm`: Требуемые оценки: подписание 25, исполнение 5

Сообщает, что `<target>` был помилован Зафодом Библброксом.

Все они принимают в своем конструкторе только один параметр: `target`. Например, "дом", если вы хотите посадить дома кустарник.

Теперь добавим константную функцию-член `execute(Bureaucrat const & executor)` в базовую форму и реализуем функцию для выполнения действия формы для конкретных классов. Вы должны убедиться, что форма подписана и что уровень бюрократа, пытающегося заполнить форму, достаточно высок. В противном случае выбрасывается соответствующее исключение.

Наконец, добавим функцию-член `executeForm(Form const & form)` в `Bureaucrat`. Она должна попытаться выполнить форму. В случае успеха напечатайте что-то вроде:
```
<bureaucrat> executed <form>
```
Если нет, выводится явное сообщение об ошибке.

### Exercise 03: At least this beats coffee-making

Поскольку заполнение форм достаточно раздражает, было бы жестоко просить наших бюрократов делать это целыми днями. К счастью, есть стажеры. В этом упражнении нужно реализовать класс `Intern`. У стажера нет ни имени, ни ранга, ни уникальных характеристик. Единственное, о чем заботятся бюрократы, это о том, чтобы они выполняли свою работу.

Однако у стажера есть одна важная возможность: функция `makeForm()`. Принимающая в качестве аргументов две строки, первая — это имя формы, а вторая — цель формы. Функция возвращает указатель на объект формы, цель которого будет инициализирована вторым параметром.

Она напечатает что-то вроде:
```
Intern creates <form>
```
Если имя формы, переданное в качестве параметра, не существует, выведется явное сообщение об ошибке.

Нужно избегать нечитаемых и уродливых решений, таких как использование леса `if`/`else if`/`else`.

###### Навигация по модулям
[<<<<](https://github.com/vrivka/cpp_04)
[00](https://github.com/vrivka/cpp_00) |
[01](https://github.com/vrivka/cpp_01) |
[02](https://github.com/vrivka/cpp_02) |
[03](https://github.com/vrivka/cpp_03) |
[04](https://github.com/vrivka/cpp_04) |
05 |
[06](https://github.com/vrivka/cpp_06) |
[07](https://github.com/vrivka/cpp_07) |
[08](https://github.com/vrivka/cpp_08) |
[>>>>](https://github.com/vrivka/cpp_06)